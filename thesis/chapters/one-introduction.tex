\mchapter{مقدمه}
\pagenumbering{arabic}
افزایش روز افزون تعداد دستگاه‌های موجود در لبه‌ی شبکه در سال‌های اخیر، و همچنین معرفی کاربردهای نرم افزاری جدید که نیازمند منابع محاسباتی بالا هستند باعث شده است که تقاضای زیادی برای خدمات رایانش ابری بوجود بیاید. رایانش ابری این امکان را به دستگاه‌های هوشمند از جمله تلفن همراه و اینترنت اشیاء می‌دهد که بخشی از پردازش‌های سنگین خود را به سرورهای قدرتمند «تخلیه» کنند تا بر محدودیت‌های پردازشی خود غلبه کنند و کاربردهای نرم افزاری پیچیده‌ای مانند واقعیت افزوده و خودروهای هوشمند را برای کاربران فراهم سازند. با این وجود، پیاده‌سازی‌های سنتی رایانش ابری یک ایراد ذاتی دارند، و آن فاصله زیاد سرورهای ابری با دستگاه‌های پایانی است. الگوی «رایانش لبه‌ای» و معماری‌های استاندارد آن مانند رایانش لبه‌ای دسترسی-چندگانه که توسط سازمان \lr{ETSI} ارائه‌شده است، سعی دارند تا با آوردن بخشی از منابع محاسباتی به نزدیکی لبه‌ی شبکه، این مشکل را تا حدی برطرف کنند.
\cite{guggulothu2019codesmelldetectionusing}
\\
علاوه بر تمایل دستگاه‌های لبه‌ی شبکه به کمتر شدن این فاصله و به عبارتی «کشش» منابع پردازشی توسط آن‌ها به منظور بهبود کیفیت سرویس، شرکت‌های ارائه‌دهنده‌ی خدمات ابری نیز تمایل دارند تا با «فشردن» بخشی از منابع پردازشی خود به لبه‌ی شبکه، بار محاسباتی و هزینه تجهیزاتی خود را کاهش دهند \Cite{edgevisions}. در جدول \ref{table:compare} مقایسه‌ای کلی از رایانش ابری و لبه‌ای ارائه‌شده است. با دقت در این جدول متوجه می‌شویم که رایانش لبه‌ای جایگزین رایانش ابری نیست بلکه مکمل آن است.\cite{das2019detecting}
\newpage
% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
\begin{table}[H]
	\centering
	\begin{tabular}{@{}lll@{}}
		\toprule
		ویژگی                 & رایانش ابری & رایانش لبه‌ای \\ \midrule
		موضع‌گیری              & مرکزی       & توزیع شده    \\
		فاصله تا دستگاه کاربر & زیاد        & کم           \\
		تاخیر                 & زیاد        & کم           \\
		تقدم و تأخر           & زیاد        & کم           \\
		منابع پردازشی         & فرآوان      & محدود        \\
		فضای ذخیره‌سازی        & فرآوان      & محدود        \\ \bottomrule
	\end{tabular}
	\caption{مقایسه‌ی رایانش ابری و لبه‌ای}
	\label{table:compare}
\end{table}
یک امر مهم در پیاده‌سازی کارآمد رایانش لبه‌ای، طراحی استراتژی‌های تخلیه‌ی وظیفه به صورت هوشمند و موثر است. این استراتژی‌ها نحوه‌ی تخصیص منابع توسط دستگاه کاربر را مشخص می‌کنند و این امکان را به دستگاه کاربر می‌دهند تا درباره تخلیه یا عدم تخلیه‌ی وظایف محاسباتی در طول زمان تصمیم بگیرد. همچنین به استراتژی تخلیه‌ای که یک تابع «هدف» خاص را تحت شرایط محیطی مشخص، کمینه یا بیشینه کند «استراتژی تخلیه‌ی بهینه» می‌گوییم. توابع هدف بر حسب یک یا چند معیار سیستم تعریف می‌شوند. برخی از این معیارها عبارتند از:
\begin{multicols}{2}
	\begin{itemize}
		\item تاخیر سرویس
		\item مصرف توان
		\item تقدم و تاخر\LTRfootnote{Jitter}
		\item هزینه
	\end{itemize}
\end{multicols}
مقدار توابع هدف و شروط مسئله‌ی تخلیه، بستگی به پارامترهای زیادی دارند، از جمله میزان منابع موجود در دستگاه کاربر، نیازمندی‌های کاربر، کیفیت شبکه‌ی دسترسی و شلوغی سرورهای رایانش لبه‌ای. علاوه بر پارامترهای محیطی، ساختار کاربردهای نرم‌افزاری نیز در مسئله‌ی تخلیه‌ی وظیفه، تاثیر می‌گذارند. برای مثال ممکن است که تمام یا بخشی از یک کاربرد خاص قابلیت تخلیه نداشته باشد \Cite{mach}. \\
جدول
\begin{longtable}{|>{\centering\arraybackslash}p{5cm}|>{\raggedright\arraybackslash}p{10cm}|}
	\caption{لیست بوی بد کد و توضیحات آن‌ها} \label{tab:code_smells_classes}                                       \\
	\hline
	\textbf{نام بوی بد کد}                       & \textbf{توضیحات}                                               \\
	\hline
	\lr{Missing Hierarchy}                       & نداشتن سلسله‌مراتب مناسب در ساختار کد                           \\
	\hline
	\lr{Long Parameter List}                     & لیست پارامترهای طولانی که درک و استفاده از متد را دشوار می‌کند  \\
	\hline
	\lr{Unnecessary Abstraction}                 & وجود انتزاعاتی که هیچ نیازی به آن‌ها نیست                       \\
	\hline
	\lr{Imperative Abstraction}                  & استفاده از انتزاعاتی که از سبک برنامه‌نویسی دستوری پیروی می‌کنند \\
	\hline
	\lr{Empty Catch Clause}                      & بلوک‌های کچ خالی که خطاها را به درستی مدیریت نمی‌کنند            \\
	\hline
	\lr{Deficient Encapsulation}                 & عدم مخفی‌سازی کافی داده‌ها و متدها در کلاس‌ها                     \\
	\hline
	\lr{Long Identifier}                         & استفاده از شناسه‌های طولانی که خوانایی کد را کاهش می‌دهد         \\
	\hline
	\lr{Multifaceted Abstraction}                & انتزاعاتی که وظایف متعددی را انجام می‌دهند                      \\
	\hline
	\lr{Wide Hierarchy}                          & سلسله‌مراتب گسترده‌ای که مدیریت را پیچیده می‌کند                  \\
	\hline
	\lr{Complex Conditional}                     & شرط‌های پیچیده که کد را سخت‌خوان و دشوار می‌سازد                  \\
	\hline
	\lr{Rebellious Hierarchy}                    & سلسله مراتبی که از اصول طراحی پیروی نمی‌کند                     \\
	\hline
	\lr{Magic Number}                            & استفاده از اعداد جادویی که معنا را در کد مخفی می‌کنند           \\
	\hline
	\lr{Missing default}                         & نداشتن مورد پیش‌فرض در ساختارهای انتخاب                         \\
	\hline
	\lr{Long Method}                             & متدهای طولانی که فهم و نگهداری آن‌ها سخت است                    \\
	\hline
	\lr{Broken Modularization}                   & ماژول‌های شکسته که وظایف را به درستی تقسیم نمی‌کنند              \\
	\hline
	\lr{Broken Hierarchy}                        & سلسله مراتبی که به درستی ساختار نیافته است                     \\
	\hline
	\lr{Unutilized Abstraction}                  & انتزاعاتی که به درستی استفاده نمی‌شوند                          \\
	\hline
	\lr{Long Statement}                          & جملات برنامه‌نویسی طولانی که خوانایی را کاهش می‌دهد              \\
	\hline
	\lr{Cyclic-Dependent Modularization}         & ماژول‌هایی که به صورت چرخه‌ای به هم وابسته‌اند                    \\
	\hline
	\lr{Multipath Hierarchy}                     & سلسله مراتبی که مسیرهای متعددی دارد                            \\
	\hline
	\lr{Deep Hierarchy}                          & سلسله‌مراتب عمیقی که پیگیری آن دشوار است                        \\
	\hline
	\lr{Hub-like Modularization}                 & ماژول‌هایی که به‌طور متمرکز عمل می‌کنند و وابستگی زیادی دارند     \\
	\hline
	\lr{Insufficient Modularization}             & ماژول‌هایی که به اندازه کافی تقسیم نشده‌اند                      \\
	\hline
	\lr{Cyclic Hierarchy}                        & سلسله مراتبی که به صورت چرخه‌ای به هم وابسته‌اند                 \\
	\hline
	\lr{Unexploited Encapsulation}               & کپسوله‌سازی که به درستی بهره‌برداری نشده است                     \\
	\hline
	\lr{Abstract Function Call From Constructor} & فراخوانی توابع انتزاعی از سازنده                               \\
	\hline
	\lr{Complex Method}                          & متدهای پیچیده که درک و نگهداری آن‌ها دشوار است                  \\
	\hline
\end{longtable}
در \CurrentProject \textbf{تاخیر سرویس} به عنوان تابع هدف در نظر گرفته شده است. تاخیر همواره یک معیار اصلی در سنجش کیفیت سامانه‌های کامپیوتری بوده است. همچنین با رشد روز افزون صنعت اینترنت اشیاء، کاربردهای جدیدی در سطح شبکه به وجود آمده است که نیازمندی‌های تاخیر بسیار پایینی دارند، به طوری که سرورهای رایانش ابری پاسخگوی این نیازمندی نخواهند بود. و از طرفی نیازمندی‌های پردازشی بالا امکان اجرای این کاربردها به صورت محلی و بی‌درنگ را نمی‌دهد. یک نمونه از این دسته از کاربردها «سامانه مدیریت ترافیک هوشمند» است که نیازمند انجام پردازش‌های سنگین در زمان بسیار کم می‌باشد. \\

تاخیر سرویس بسته به اجرای محلی و یا تخلیه از مولفه‌های متفاوتی تشکیل می‌شود. در صورت اجرای محلی تاخیر سرویس از موارد زیر تشکیل خواهد بود:
\begin{enumerate}
	\item تاخیر انتظار در صف وظیفه $d_q$
	\item تاخیر اجرا به صورت محلی $d_{l o c}$
\end{enumerate}
و در صورت تخلیه از موارد زیر تشکیل خواهد شد:
\begin{enumerate}
	\item تاخیر صف $d_q$
	\item تاخیر ارسال $d_{t x}$
	\item تاخیر انتشار $d_{p r o p a g a t i o n}$
	\item تاخیر اجرا در سرور لبه‌ای $d_{s e r v e r}$
	\item تاخیر بازدریافت وظیفه از سرور $d_{r x}$
\end{enumerate}
در \CurrentProject روشی برای بدست آوردن استراتژی تخلیه‌ی وظیفه‌ی تاخیر-کمینه تحت محدودیت توان مصرفی ارائه می‌دهیم. روش ارائه‌شده، مبتنی بر زنجیره‌ی مارکوف گسسته-زمان و برنامه‌ریزی خطی می‌باشد و گسترشی بر روش ارائه‌شده در \Cite{Liu} می‌باشد. نوآوری و مزیت اصلی روش پیشنهادی نسبت به مقاله ذکر شده،‌ قابلیت پشتیبانی از وظایف با نیازمندی‌های پردازشی و شبکه‌ای متفاوت (وظایف ناهمگون) می‌باشد. انگیزه‌ی اصلی از این گسترش، تنوع محاسباتی وظایف در محیط‌های اینترنت اشیاء بوده است. به طور مثال در بسیاری از پژوهش‌های حوزه تخلیه‌ی وظیفه در اینترنت اشیاء، وظایف به دو دسته «سبک» و «سنگین» تقسیم می‌شوند \Cite{yousefpour, tran}. برای درک مفهوم وظایف سبک و سنگین می‌توان مثال اتومبیل خودران را در نظر گرفت. در این کاربرد، وظیفه پردازش اطلاعات تصاویر به منظور راندن خودرو یک وظیفه سنگین محسوب می‌شود، در حالی که وظیفه‌ روشن کردن سیستم گرمایشی خودرو بر حسب داده‌ی سنسور دما، یک وظیفه سبک محسوب می‌شود.

%TODO: Overview

ادامه‌ی پروژه به پنج فصل تقسیم شده است. در فصل ۲ پژوهش‌های مرتبط انجام شده را مرور می‌کنیم. در فصل ۳ به شرح مسئله‌ی تخلیه‌ی وظیفه و ساختار رایانش لبه‌ای می‌پردازیم. در فصل ۴ روش پیشنهادی برای بدست آوردن استراتژی تخلیه‌ی بهینه را شرح می‌دهیم. در فصل ۵ نحوه‌ی پیاده‌سازی عملی روش پیشنهادی را در قالب چارچوب نرم‌افزاری جدیدی با نام «کامپیوت\LTRfootnote{Kompute}» ارائه می‌دهیم. در فصل ۶ با استفاده از چارچوبِ کامپیوت، به آزمایش و شبیه‌سازی روش پیشنهادی می‌پردازیم. در انتها در فصل ۷ یک جمع‌بندی کلی از تمامی مطالب ارائه می‌دهیم و پیشنهاداتی برای گسترش روش پیشنهادی عنوان می‌کنیم.
\clearpage
